# Introduction to Programming Languages

## What is a Programming Language?

![Programming language](https://github.com/nirajan10/C-notes/blob/main/images/programming-language.png?raw=true)
A programming language is a set of rules and syntax for writing instructions that a computer can understand. It is a bridge between human-readable code and binary instructions that the computer runs.

## Why Use Programming Languages?

- **Readability**: Binary is hard for humans to work with, so languages provide a clearer way to write instructions.
- **Abstraction**: They simplify complex operations, letting programmers focus on logic rather than hardware details.
- **Efficiency**: Languages offer tools like loops and functions for concise, reusable code.

**Example**: To display "Welcome!" on the screen, you write a simple command in a programming language, which is translated into binary for the computer.

## Why So Many Languages?

Languages vary to suit different needs:

- **Specific Purposes**: Some are optimized for web development, others for system programming or data analysis.
- **Performance vs. Simplicity**: Some prioritize speed, others ease of use.
- **Evolution**: New languages address limitations of older ones or adapt to new technologies.
- **Preference**: Programmers choose languages based on familiarity or project needs.

## Types of Programming Languages

Languages are categorized by execution method or abstraction level.

### By Execution Method

1. **Compiled Languages**:
![Compiler](https://github.com/nirajan10/C-notes/blob/main/images/compiler.png?raw=true)
      - **Definition**: Code is written, then translated (compiled) into machine code before running.
      - **Characteristics**: Faster execution since translation happens once.
      - **Example**: A program is compiled into an executable file that runs directly.
      - **Relevance**: C is a compiled languageâ€”you write it, you compile it, and you run the resulting program.

2. **Interpreted Languages**:
![Interpreter](https://github.com/nirajan10/C-notes/blob/main/images/interpreter.png?raw=true)
      - **Definition**: Code is executed line-by-line by an interpreter at runtime, without compiling first.
      - **Characteristics**: Slower but easy to debug and change at runtime.
      - **Example**: The interpreter translates and runs each line of code directly.

### By Abstraction Level

![Language level](https://github.com/nirajan10/C-notes/blob/main/images/language-level.png?raw=true)

1. **Low-Level Languages**:
      - **Definition**: Closer to machine code, offering direct hardware control.
      - **Characteristics**: Fast but complex, requiring knowledge of computer architecture.
      - **Example**: The assembly language uses mnemonic codes for processor instructions.

2. **High-Level Languages**:
      - **Definition**: Closer to human language, abstracting hardware details.
      - **Characteristics**: Easier to learn but may be less efficient.
      - **Example**: C is a high-level language with low-level capabilities, balancing ease and control.

## Why Learn a Language Like C?

- **Efficiency**: C offers fast performance and control over system resources, ideal for system programming.
- **Foundation**: Learning C teaches how computers work, a skill transferable to other languages.
- **Versatility**: Used in operating systems, embedded systems, and performance-critical applications.

**Example**: In C, to add two numbers:

```c
int sum = a + b;
```

This simple syntax abstracts the binary operations the computer performs.
